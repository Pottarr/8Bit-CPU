\documentclass[12pt]{report}

\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage{array}
\usepackage{amsmath, amssymb}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{lipsum}
\usepackage{minted}
\usepackage{rotating}
\usepackage{tabularx}
\usepackage{titlesec}
\usepackage{tocloft}

\setlength{\parindent}{1cm}
\setlength{\parskip}{5pt}

\titlespacing*{\chapter}{0pt}{0.5cm}{0.5cm}
\titlespacing*{\section}{0pt}{0.25cm}{0.25cm}

\setlength{\cftbeforetoctitleskip}{1cm}
\setlength{\cftaftertoctitleskip}{1cm}

\begin{document}

\begin{titlepage}
	\centering
    \vspace*{\fill}
	\includegraphics[width=0.3\textwidth]{./images/KMITL Logo.png} \\
	\vspace{1cm}
	{\LARGE \textbf{8 Bits CPU Simulation Documentation}} \\[0.5cm]
	\vspace{0.5cm}
	{\large \textbf{Compter Architecture and Organization}} \\[0.5cm]
	{\large \textbf{Software Engineering Program,}} \\[0.5cm]
	{\large \textbf{Department of Computer Engineering,}} \\[0.5cm]
	{\large \textbf{School of Engineering, KMITL}} \\[1cm]
	{\Large 67011093 Chavit Saritdeechaikul} \\[0.25cm]
    {\Large 67011352 Theepakorn Phayonrat}
    \vspace*{5cm}
    \vspace*{\fill}
\end{titlepage}

% Preface page
\chapter*{Preface}

This project, Design and Implementation of a Minimal 8-Bit CPU, was
undertaken as part of the Computer Architecture and Organization course
in the second year of Bachelor of Software Engineering at KMITL.
It represents a practical exploration of fundamental computer architecture
concepts, from logic design to instruction execution. The project allowed
us to apply theoretical knowledge of CPU structure, instruction sets,
and pipelining into a fully simulated and functioning processor. Using
the Digital simulator by Hneemann, we developed and verified a modular
CPU that embodies the essence of real processor operation. This report
documents the design process, implementation details, and lessons
learned throughout the development cycle.

\newpage

% Abstract page
\chapter*{Abstract}

This mini project focuses on the design and simulation of a minimal
8-bit pipelined CPU using the Digital circuit simulation software.
The CPU incorporates a five-stage pipeline: Fetch, Decode, Execute,
Memory, and Write Back—and supports a custom instruction set architecture
(ISA) with arithmetic, logical, branching, and I/O operations.
The architecture features separate ROM and RAM modules, basic input
and output ports, and a status register for flag management. Through
simulation and test programs, the system demonstrates instruction
execution, branching control, and interrupt handling. The project
enhances understanding of CPU internals, digital logic integration,
and the challenges of pipelined design, offering a hands-on approach 
to fundamental architectural concepts.

\newpage

% Table of contents
\tableofcontents
\newpage

% Chapter 1: Introduction
\chapter{Introduction}
\section{Project Overview}

The 8-Bit CPU Simulation project aims to implement a simplified,
educational model of a pipelined processor that captures the essential
operations of modern CPUs while remaining manageable for simulation.
The design follows a five-stage pipeline (Instruction Fetch,
Instruction Decode, Execute, Memory, Write Back), allowing concurrent 
instruction processing for improved efficiency.

The CPU operates with 8-bit data paths and addresses, includes
general-purpose and a special register (flag status register), and
separates program memory (ROM) from data memory (RAM). A custom
instruction set defines all operations, including data transfer
(LD, ST, MOV), arithmetic and logic (ADD, SUB, MUL, AND, OR, XOR, NOT),
branching (BZ, BNZ, BC, B), and I/O handling (RD, WR). Interrupt support
and optional features such as basic caching or branch prediction may 
extend functionality.

Simulation and verification are performed in Digital, emphasizing
modularity, waveform analysis, and clear documentation.

\newpage

\section{Background}

Central Processing Units (CPUs) are the computational core of digital
systems, responsible for executing instructions and managing data flow
between memory and peripherals. Understanding how a CPU functions—from
fetching an instruction to writing back results—is crucial in computer
engineering education.

Traditional classroom learning often focuses on theoretical aspects
such as microarchitecture, ISA design, and pipelining, but lacks
direct visualization of hardware behavior. This project bridges that
gap by using the Digital simulator to implement a CPU from basic logic
components. By designing each pipeline stage, students explore how
control signals, registers, buses, and memory interact to form a
functioning processor.

The project serves as a foundational experience in CPU design, 
illustrating key topics such as instruction decoding, data hazards,
memory access timing, and modular circuit organization.


\section{Objective}

\begin{enumerate}
    \item \textbf{To design and implement} an 8-bit pipelined CPU with a custom instruction set architecture (ISA) using the \textit{Digital} simulation environment.
    \item \textbf{To apply theoretical concepts} of CPU architecture, including pipeline stages, ALU operations, branching, and flag management, in a practical design.
    \item \textbf{To develop modular circuit components} (e.g., ALU, control unit, registers, and memory interfaces) that integrate seamlessly within the pipeline.
    \item \textbf{To simulate and verify} the CPU’s operation through test programs demonstrating arithmetic, logic, branching, stack, and interrupt handling.
    \item \textbf{To enhance understanding} of digital logic design, data path organization, and hardware–software interaction in CPU execution.
    \item \textbf{To document} the architecture, instruction formats, and verification results clearly and comprehensively for academic evaluation.
\end{enumerate}

\chapter{Project Overview}
\section{Hardware Design}

\subsection{Structure}

\subsection{Overall Structure}

\includegraphics[width=\textwidth]{images/CPU.png} \\

\subsection{Pipeline Stages Dive Through}

\textbf{Instruction Fetch Stage Part}

\begin{center}
\includegraphics[width=0.5\textwidth]{images/IF.png} \\
\end{center}

Fetch instruction to the \texttt{IF/ID} pipeline to be used to decode
in the next stage.

\newpage

\textbf{Instruction Decode Stage Part}

\includegraphics[width=\textwidth]{images/ID.png} \\

Decode the instruction and transfer to the \texttt{ID/EX} pipeline to
execute in the next stage. In here, the system fetch the immediate
value from the $R_{Dest}$ $R_{Src1}$, if the system detects the
$IMM_{Check}$ is $0$ it also fetch immediate value from $R_{Src2}$
(The last 3 bits of the 20 bit instruction). Else, the system takes
the last 8 bits of the instruction as the immediate value for that
instruction executing in the next stage.

In the \texttt{Control Unit (CU)} we load the opcode into it and it
output the execute signal for each opcode. \\

\newpage

\noindent \texttt{CU\_ROM.hex}

\inputminted[fontsize=\scriptsize, breaklines, breakanywhere, breakindent=1em]{hex}{../test/CU_ROM.hex}

\noindent Control Unit Signal Format (Length: 6 bits): \\
$$NOP [5]\ | \ Do_{SMTH} [4:3]\ |\ SMTH_{Choice} [2:0]$$

\begin{center}
\scalebox{0.5}{
\[
\setlength{\extrarowheight}{5pt} % Adds 5pt to each row's height
\begin{array}{|l|l|l|}
\hline
\textbf{Format} & \textbf{Signal} & \textbf{Description} \\[4pt]
\hline
Do_{Jump} \text{ Signal} &\ &\ \\
Do_{BC} & 0\ 00\ 000 & BC \text{ in } EX:Do_{Jump} \\[2pt]
Do_{BZ} & 0\ 00\ 001 & BZ \text{ in } EX:Do_{Jump} \\[2pt]
Do_{BNZ} & 0\ 00\ 010 & BNZ \text{ in } EX:Do_{Jump} \\[2pt]
Do_{BNG} & 0\ 00\ 011 & BNG \text{ in } EX:Do_{Jump} \\[2pt]
Do_{B} & 0\ 00\ 100 & B \text{ in } EX:Do_{Jump} \\[2pt]
\hline
Do_{Math} \text{ Signal} &\ &\ \\
Do_{ADD} & 0\ 01\ 000 & ADD \text{ in } EX:Do_{Math} \\[2pt]
Do_{SUB} & 0\ 01\ 001 & SUB \text{ in } EX:Do_{Math} \\[2pt]
Do_{MUL} & 0\ 01\ 010 & MUL \text{ in } EX:Do_{Math} \\[2pt]
Do_{AND} & 0\ 01\ 100 & AND \text{ in } EX:Do_{Math} \\[2pt]
Do_{OR} & 0\ 01\ 101 & OR \text{ in } EX:Do_{Math} \\[2pt]
Do_{XOR} & 0\ 01\ 110 & XOR \text{ in } EX:Do_{Math} \\[2pt]
Do_{NOT} & 0\ 01\ 111 & NOT \text{ in } EX:Do_{Math} \\[2pt]
\hline
Do_{Mem} \text{ Signal} &\ &\ \\
Do_{LD} & 0\ 10\ 010 & XOR \text{ in } ME:Do_{RAM} \\[2pt]
Do_{ST} & 0\ 10\ 011 & NOT \text{ in } ME:Do_{RAM} \\[2pt]
Do_{POP} & 0\ 10\ 110 & XOR \text{ in } ME:Do_{Stack} \\[2pt]
Do_{PSH} & 0\ 10\ 111 & NOT \text{ in } ME:Do_{Stack} \\[2pt]
\hline
Do_{I/O\|MOV} \text{ Signal} &\ &\ \\
Do_{RD} & 0\ 10\ 010 & RD \text{ in } EX:Do_{I/O\|MOV} \\[2pt]
Do_{WR} & 0\ 10\ 011 & WR \text{ in } EX:Do_{I/O\|MOV} \\[2pt]
Do_{MOV} & 0\ 10\ 000 & MOV \text{ in } ME:Do_{I/O\|MOV} \text{, ready to write back in } WB \\[2pt]
\hline
\text{NOP Signal} &\ &\ \\
NOP & 1\ |\ DC [4:0] & \text{No Operation} \\[2pt]
\hline
\end{array}
\]
}
\end{center}

\newpage

\textbf{Execute Stage Part}

\begin{center}
\includegraphics[width=\textwidth]{images/EX.png} \\
\end{center}

In this stage, each instruction has 4 choices, whether to go do the
calculation in the \texttt{ALU} or do the branch taking or do
the \texttt{I/O} process or to pass through without doing anything.

If the instruction is a jump instruction (\texttt{BC} or \texttt{BZ} or
\texttt{BNZ} or \texttt{BNG} or \texttt{B}), the system will start the
pipeline flushing process by flushing the 2 instructions coming later in
\texttt{IF} and \texttt{ID} stages and fill with \texttt{NOP} instruction
to cleanup, then the system will fetch the instruction in the
\texttt{Instruction Register} where address is equal to
\texttt{Program Counter} value given in the instruction.

\newpage

\textbf{Memory Stage Part}

\begin{center}
\includegraphics[width=\textwidth]{images/ME.png} \\
\end{center}

In this stage each instruction has 3 choices, whether to pass through
without doing anything, to load data into the \texttt{RAM} or to fetch
data out from the \texttt{RAM}. If the instruction is either \texttt{LD}
or \texttt{POP} the \texttt{RAM} outputs the data to the next stage.
Else if the instruction is \texttt{ST} or \texttt{PSH} the \texttt{RAM}
input data into the memory address given as the immediate or register
to fetch address from.

If the instruction is a stack instruction (\texttt{PSH} or \texttt{POP}),
the data will load and fetch from the back most of the \texttt{RAM}
and will increment or decrement the \texttt{Stack Pointer} base on the
instruction.

\newpage

\textbf{Write Back Stage Part}

\begin{center}
\includegraphics[width=\textwidth]{images/WB.png} \\
\end{center}

Once every data are processed in each pipeline stage, in \texttt{Wb}
stage, they are now ready to be written back into the
\texttt{Register File}. For the condition to enable the write
back, the instruction needs to be either arithmetic or logic or
\texttt{RD} or \texttt{LD} or \texttt{POP}. All of these instruction
all give back value to be loaded into the register in the
\texttt{Register File}.

\newpage

\subsection{Pipeline Buffers Dive Through}

\begin{center}
\includegraphics[height=0.225\paperheight]{images/IF-ID.png}
\hfill
\includegraphics[height=0.225\paperheight]{images/ID-EX.png}
\hfill
\includegraphics[height=0.225\paperheight]{images/EX-ME.png}
\hfill
\includegraphics[height=0.225\paperheight]{images/ME-WB.png}
\end{center}

Pipeline buffers are placed between stages to prevent data and control
signals to overlap in each stage.\subsection{Other Parts Dive Through}

\textbf{Program Counter and I/O Parts}

\begin{center}
\includegraphics[width=0.75\textwidth]{images/PC-IO.png} \\
\end{center}

For input and output value for the system and for control the instruction
to be done in each pipeline stages via \texttt{Program Counter (PC)}.

\newpage

\subsection{Inner Components Dive Through}

\textbf{ALU}

\begin{center}
\includegraphics[width=\textwidth]{images/ALU.png} \\
\end{center}

Get the Decision choice value in 3 bits and 2, 8 bits data to
calculate. The output result and flags are depended on the calculation.
E.g. Using MUL may cause Overflow flag while SUB may cause Negative Flag.

\newpage

\textbf{Half Adder}

\begin{center}
\includegraphics[width=0.5\textwidth]{images/half_adder.png} \\
\end{center}

Simplest form of 1 bit adder.

\textbf{Full Adder}

\begin{center}
\includegraphics[width=0.5\textwidth]{images/full_adder.png} \\
\end{center}

1 bit adder that can have carry input.

\textbf{8Bit Adder}

\begin{center}
\includegraphics[width=0.75\textwidth]{images/8bits_adder.png} \\
\end{center}

8 Full Adders combine to make system available for 8 bits
binary addition.

\newpage

\textbf{8Bit Multiplier}

\begin{center}
\includegraphics[width=\textwidth]{images/8bits_multiplier.png} \\
\end{center}

Bit-shifting each line and add up together. If the value
exceed 8 bits, it toggles Overflow Flag in the ALU.

\newpage

\textbf{Multiplier Helper}

\begin{center}
\includegraphics[width=0.75\textwidth]{images/multiply_check_helper.png} \\
\end{center}

Help to set the binary ready before bit-shifting

\textbf{Data Forwarding Register}

\begin{center}
\includegraphics[width=\textwidth]{images/forward_register.png} \\
\end{center}

Help to prevent Data Hazard if the earlier instructions have the same
register used in the later instructions. It can be called from here.
Every instruction result executed in EX and its destination register
are stored here for a while then if in no used it drops.

\newpage

\subsection*{Pipeline States}

\begin{enumerate}
    \item \textbf{Instruction Fetch} (\texttt{IF}): The \textt{CPU}
        fetch the instruction line by line from the ROM.
    \item \textbf{Instruction Decode} (\texttt{ID}): The \texttt{CPU}
        decode the instruction line we fetch from \texttt{IF} and
        decode to extract each part of the instruction (e.g. $R_{Dest}$,
        $R_{Src1}$, $R_{Src2}$, $\#IMM$) to be used in the later stages
        of pipeline.
    \item \textbf{Execute} (\texttt{EX}): Every instruction which does
        not use the \texttt{RAM} are done here. The data can be forward
        for the later instructions and can transfer to the later pipeline
        stages too.
    \item \textbf{Memory} (\texttt{ME}): The data that use \texttt{RAM}
        are done here (e.g. \texttt{PSH}, \texttt{POP}, \texttt{LD},
        \texttt{ST}). For the instructions with data as output, the
        output will combine with the $R_{Dest}$ transferred from earlier
        pipeline stages and transfer to \texttt{WB} stage.
    \item \textbf{Write Back} (\texttt{WB}): The data transferred from
        earlier stages are now ready to be written back to
        \texttt{Register File}.
\end{enumerate}

\subsection*{Pipeline Hazards Management}

\begin{enumerate}
    \item \textbf{Structural Hazards}: Fixed my 2 concepts
        \begin{enumerate}
            \item Calculation must be done before accessing RAM or WB stage
            \item Accessing RAM with LD instruction will return value
                therefore it must be done before WB stage.
        \end{enumerate}
    \item \textbf{Data Hazards}: Fixed by creating
        \texttt{Data Forwarding Register}.
    \item \textbf{Control Hazards}: If prediction is wrong the system
        will the flush pipeline with \texttt{NOP}
\end{enumerate}

\newpage

\section{Software Design}

\subsection{Instructions}

\noindent Instruction Format (Length: 20 bits): \\
$$Opcode [19:15]\ |\ IMM_{Flag} [14]\ |\ R_{Dest}\ [13:11]\ |\ R_{Src1}\ |\ R_{Src2} [2:0]\ or\ IMM [7:0]$$

\begin{center}
\scalebox{0.6}{
\[
\setlength{\extrarowheight}{5pt} % Adds 5pt to each row's height
\begin{array}{|l|l|l|}
\hline
\textbf{Instruction} & \textbf{Opcode + Fields} & \textbf{Description} \\[4pt]
\hline
\text{Do in } IF & & \\
NOP & 00000\ |\ IMM_{Flag} [14]\ |\ DC[13:0] & \text{No Operation} \\[4pt]
\hline
\text{Do in } EX_{ALU} & & \\
ADD & 00100\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ R_{Src1} [10:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Addition} \\[4pt]
SUB & 00101\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ R_{Src1} [10:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Subtraction} \\[4pt]
MUL & 00110\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ R_{Src1} [10:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Multiplication} \\[4pt]
AND & 01000\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ R_{Src1} [10:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Bitwise AND} \\[4pt]
OR  & 01001\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ R_{Src1} [10:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Bitwise OR} \\[4pt]
XOR & 01010\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ R_{Src1} [10:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Bitwise XOR} \\[4pt]
NOT & 01011\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ DC [10:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Bitwise NOT} \\[4pt]
\hline
\text{Do in } EX_{JUMP} & & \\
BC & 10000\ |\ IMM_{Flag} [14]\ |\ DC [13:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Branch if Carry} \\[4pt]
BZ  & 10001\ |\ IMM_{Flag} [14]\ |\ DC [13:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Branch if Zero} \\[4pt]
BNZ & 10010\ |\ IMM_{Flag} [14]\ |\ DC [13:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Branch if Not Zero} \\[4pt]
BNG & 10011\ |\ IMM_{Flag} [14]\ |\ DC [13:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Branch if Negative} \\[4pt]
B & 10100\ |\ IMM_{Flag} [14]\ |\ DC [13:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Unconditional Branch} \\[4pt]
\hline
\text{Do in } EX_{I/O} & & \\
RD  & 10110\ |\ DC [14:3]\ |\ R_{Src2} [2:0] & \text{Read input value to register} \\[4pt]
WR  & 10111\ |\ DC [14:3]\ |\ R_{Src2} [2:0] & \text{Write value from register to output} \\[4pt]
\hline
\text{Do in } ME_{RAM} & & \\
LD & 11000\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ DC [10:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Load value from memory to register} \\[4pt]
ST & 11001\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ DC [10:8]\ |\ R_{Src2} [2:0]\ or\ \#IMM [7:0] & \text{Store register to memory} \\[4pt]
\hline
\text{Do in } ME_{Stack} & & \\
PSH & 11010\ |\ DC [14:3]\ |\ R_{Src2} [2:0] & \text{Push } R_{Src2} \text{ value into Stack} \\[4pt]
POP & 11011\ |\ DC [14:3]\ |\ R_{Src2} [2:0] & \text{Pop the top register value from the Stack} \\[4pt]
\hline
\text{Do in } WB & & \\
MOV & 11110\ |\ IMM_{Flag} [14]\ |\ R_{Dest} [13:11]\ |\ R_src1 [2:0]\ or\ #IMM [7:0] & \text{Move value from} R_{Src1} \text{ or } \#IMM \text{ into } R_{Src1} \\[4pt]
\hline
\end{array}
\]
}
\end{center}

\newpage

\subsection{Assembler}

We had written an assembler in Python. \\

\noindent \texttt{compiler.py}

\inputminted[fontsize=\scriptsize, breaklines, breakanywhere, breakindent=1em]{py}{../test/compiler.py}

\newpage

\chapter{Installation and Execution Guide}

\section{Prerequisites}
\begin{itemize}
    \item Have git install in your system
    \item Have Hneemann's Digital installed in your system
\end{itemize}

\section{Git Clone from the Remote Repository}
\begin{lstlisting}[language=Bash ,basicstyle=\footnotesize\ttfamily]
git clone https://github.com/Pottarr/8Bit-CPU
\end{lstlisting}

After that you can open the \texttt{CPU.dig} in through your Digital.
\section{Test Assembly Code}

\subsection{Test 1: Overall Instructions}
\noindent \texttt{test1.ass}
\inputminted[fontsize=\scriptsize, breaklines, breakanywhere, breakindent=1em]{}{../test/test1.ass}

\newpage

\subsection{Test 2: Data Hazard Check}
\noindent \texttt{test2.ass}
\inputminted[fontsize=\scriptsize, breaklines, breakanywhere, breakindent=1em]{}{../test/test2.ass}

\subsection{Test 3: Structure Hazard and Control Hazard Check}
\noindent \texttt{test3.ass}
\inputminted[fontsize=\scriptsize, breaklines, breakanywhere, breakindent=1em]{}{../test/test3.ass}

\subsection{Test 4: Stack Warning Check}
\noindent \texttt{test4.ass}
\inputminted[fontsize=\scriptsize, breaklines, breakanywhere, breakindent=1em]{}{../test/test4.ass}

\newpage

\subsection{Test 5: I/O Test}
\noindent \texttt{test5.ass}
\inputminted[fontsize=\scriptsize, breaklines, breakanywhere, breakindent=1em]{}{../test/test5.ass}

\newpage

\chapter{Summary}

\section{Project Summary}

The \textit{Design and Implementation of a Minimal 8-Bit CPU} project focuses on creating a functional pipelined processor using the \textit{Digital} simulation software. 
This project integrates theoretical and practical knowledge of computer architecture by designing a five-stage pipelined CPU that executes a custom instruction set architecture (ISA). 
It emphasizes modular design, digital logic integration, and simulation-based verification of CPU functionalities such as arithmetic operations, branching, and interrupt handling.

\section{Challenges faced with Solutions}
\begin{center}
    \setlength{\extrarowheight}{5pt} % Adds 5pt to each row's height
    \begin{tabular}{| m{7.75cm} | m{7.75cm} |}
        \hline
        \textbf{Challenge} & \textbf{Solution} \\[4pt]
        \hline
        CU was too complex using MUX. & Use ROM in CU as signal provider instead. \\
        \hline
        Manually converting Assembly code into Binary code and insert line by line into IR was difficult. & Create a compiler to compile Assembly code to Hex code and load into the IR. \\
        \hline
        There were too many tangled cables in the circuit. & Use tunnel component to make the circuit more organize. \\
        \hline
        RD instruction needed very precise timing set input a value. & Make the input receive the input value available in the input port in that moment of execution. (Therefore, users can pre-input the value and wait for the instruction to execute.) \\
        \hline
        We fetch wrong data when we want to fetch data before editing. & Try falling edge signal. \\
        \hline
    \end{tabular}
\end{center}

\newpage

\section{Learning Outcomes}

\begin{itemize}
    \item Successfully implemented a fully functional 8-bit pipelined CPU with distinct stages: Fetch, Decode, Execute, Memory, and Write Back.
    \item Developed a custom instruction set architecture (ISA) supporting arithmetic, logic, branching, and I/O operations.
    \item Designed and simulated essential CPU modules including the ALU, control unit, registers, and memory units (ROM and RAM).
    \item Implemented flag registers (Zero, Non-Zero, Carry) to support conditional branching and status tracking.
    \item Demonstrated interrupt handling and basic I/O communication using input and output ports.
    \item Verified CPU functionality using test programs, simulation waveforms, and step-by-step execution tracing.
\end{itemize}

\section{Accomplishments}

\begin{itemize}
    \item Gained hands-on experience in digital logic and CPU design principles through simulation.
    \item Applied theoretical knowledge of pipelining and instruction execution to a practical, working model.
    \item Improved understanding of hardware design challenges such as data hazards and control flow management.
    \item Strengthened teamwork, modular circuit design, and documentation skills.
    \item Completed a comprehensive report and video demonstration showcasing CPU functionality and performance.
\end{itemize}

\section{Further Development}

We have planned to implement the SWI (Software Interrupt) into our CPU.
But due to project time period was not enough, therefore we might implement
it in the future.

\newpage

% References/Bibliography section
\chapter{References}
% Include your references here in the proper LaTeX format, or use a BibTeX file
\begin{itemize}
    \item  \href{https://github.com/Pottarr/KMITL-SE-Classes-Archive/blob/main/SE16/Year2/Semester1/Computer-Organization-and-Architecture/Digital%20Design%20and%20Computer%20Architecture%20ARM%20Edition.pdf}{Digital Design and Computer Architecture ARM Edition}
    \item  \href{https://www.youtube.com/watch?v=6u2rzB3HtXM}{How to build a computer TUTORIAL}
\end{itemize}

\newpage

\chapter{Appendix}

\section{Github Repositories}
\begin{itemize}
    \item This project repository: \url{https://github.com/Pottarr/8Bit-CPU}
    \item Helmut Neemann's Digital repository: \url{https://github.com/hneemann/Digital}
\end{itemize}

\end{document}
